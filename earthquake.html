<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Earthquakes in Japan</title>

  <!-- Leaflet CSS and JS (no token required) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    html, body {
      height: 100%;
      margin: 0;
      font-family: Arial, sans-serif;
    }

    /* Sidebar on the left as required */
    #sidebar {
      position: absolute;
      left: 0;
      top: 0;
      width: 340px;
      height: 100%;
      background: rgba(255, 255, 255, 0.95);
      overflow-y: auto;
      padding: 10px;
      box-shadow: 2px 0 5px rgba(0,0,0,0.2);
      z-index: 400;
    }

    /* Map shifted right to make room for left sidebar */
    #map {
      position: absolute;
      top: 0;
      left: 340px;
      width: calc(100% - 340px);
      height: 100%;
    }

    h2 {
      text-align: center;
      margin-top: 0;
    }

    table {
      width: 100%;
      border-collapse: collapse;
    }

    th, td {
      border-bottom: 1px solid #ccc;
      padding: 6px;
      text-align: left;
    }

    th {
      background-color: #f4f4f4;
      cursor: pointer;
    }

    @media (max-width: 1024px) {
      #sidebar { display: none; }
      #map { left: 0; width: 100%; }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div id="sidebar">
    <h2>Recent Earthquakes in Japan</h2>
    <table id="infoTable">
      <thead>
        <tr>
          <th onclick="sortTable(0)">Prefecture</th>
          <th onclick="sortTable(1)"># Earthquakes</th>
        </tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>
    <p style="font-size:12px;color:#666;margin-top:8px">If data doesn't load when opening this file directly (file://), run a local server (e.g. from project folder: <code>python -m http.server</code>) and open http://localhost:8000</p>
  </div>

  <script>
    // --- Configuration ---
    // Provide your Mapbox access token here to use Mapbox tiles. If left as the placeholder, the app will fall back to OpenStreetMap tiles.
    const MAPBOX_TOKEN = '<YOUR_MAPBOX_ACCESS_TOKEN>';

    // Initialize Leaflet map centered roughly on Japan
    const map = L.map('map').setView([37.5, 138], 5);

    // Choose tile provider: Mapbox if token provided, otherwise OpenStreetMap
    if (MAPBOX_TOKEN && MAPBOX_TOKEN !== '<YOUR_MAPBOX_ACCESS_TOKEN>') {
      L.tileLayer(`https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=${MAPBOX_TOKEN}`, {
        id: 'mapbox/streets-v11',
        tileSize: 512,
        zoomOffset: -1,
        maxZoom: 19,
        attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, Imagery © <a href="https://www.mapbox.com/">Mapbox</a>'
      }).addTo(map);
    } else {
      // Fallback to OpenStreetMap (works without tokens)
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);
      if (!MAPBOX_TOKEN || MAPBOX_TOKEN === '<YOUR_MAPBOX_ACCESS_TOKEN>') {
        console.warn('Mapbox token not provided — using OpenStreetMap tiles. To use Mapbox tiles, set MAPBOX_TOKEN in the script.');
      }
    }

    // Load both GeoJSON datasets asynchronously
    Promise.all([
      fetch('assets/japan.json').then(res => res.json()),
      fetch('assets/earthquakes.geojson').then(res => res.json())
    ])
    .then(([japan, quakes]) => {
      // Add Japan prefecture polygons
      const prefectureLayer = L.geoJSON(japan, {
        style: {
          color: '#0077b6',
          weight: 1,
          fillColor: '#74c0fc',
          fillOpacity: 0.2
        }
      }).addTo(map);

      // Prepare prefecture features
      const prefectures = japan.features;

      // For each earthquake, find which prefecture it is in (or null)
      const quakeFeatures = (quakes.features || []).filter(f => f.geometry && f.geometry.type === 'Point');
      const turfPoints = quakeFeatures.map(f => turf.point(f.geometry.coordinates, f.properties));
      const prefectureQuakeMap = {};
      prefectures.forEach(pref => {
        prefectureQuakeMap[pref.properties.name] = [];
      });
      turfPoints.forEach((pt, i) => {
        let found = false;
        for (const pref of prefectures) {
          if (turf.booleanPointInPolygon(pt, pref)) {
            prefectureQuakeMap[pref.properties.name].push(quakeFeatures[i]);
            found = true;
            break;
          }
        }
        // Optionally, could track earthquakes not in any prefecture
      });

      // Add earthquake points (only those in Japan)
      const filteredQuakes = {
        type: 'FeatureCollection',
        features: quakeFeatures.filter((f, i) => {
          // Only keep if in any prefecture
          return turfPoints[i] && prefectures.some(pref => turf.booleanPointInPolygon(turfPoints[i], pref));
        })
      };
      const quakeLayer = L.geoJSON(filteredQuakes, {
        pointToLayer: (feature, latlng) => {
          const mag = (feature.properties && feature.properties.mag) || 3;
          const color =
            mag >= 6 ? "red" :
            mag >= 5 ? "orange" :
            mag >= 4 ? "yellow" :
            "green";
          return L.circleMarker(latlng, {
            radius: Math.max(4, mag * 2),
            fillColor: color,
            color: color,
            weight: 1,
            fillOpacity: 0.8
          }).bindPopup(
            `<b>${(feature.properties && feature.properties.place) || "Unknown location"}</b><br>Magnitude: ${mag}`
          );
        }
      }).addTo(map);

      // Auto-zoom to data (only if bounds valid)
      try {
        const bounds = quakeLayer.getBounds();
        if (bounds && bounds.isValid && bounds.isValid()) {
          map.fitBounds(bounds);
        }
      } catch (e) {
        console.warn('Could not auto-fit bounds:', e);
      }

      // Populate sidebar table with prefecture counts
      populateTable(prefectures, prefectureQuakeMap);
    })
    .catch(err => console.error('Error loading GeoJSON:', err));

    // Sidebar table: all prefectures, with earthquake count (including zero)
    function populateTable(prefectures, quakeMap) {
      const tbody = document.getElementById('tableBody');
      tbody.innerHTML = '';
      // Sort by count descending, then name
      const sorted = [...prefectures].sort((a, b) => {
        const ca = quakeMap[a.properties.name].length;
        const cb = quakeMap[b.properties.name].length;
        if (cb !== ca) return cb - ca;
        return a.properties.name.localeCompare(b.properties.name);
      });
      sorted.forEach(pref => {
        const name = pref.properties.name;
        const count = quakeMap[name].length;
        const row = document.createElement('tr');
        row.innerHTML = `<td>${name}</td><td>${count}</td>`;
        row.style.cursor = 'pointer';
        row.title = count > 0 ? 'Click to zoom to prefecture and highlight earthquakes' : 'Click to zoom to prefecture';
        row.addEventListener('click', () => {
          // Zoom to prefecture
          const layer = L.geoJSON(pref);
          try {
            const bounds = layer.getBounds();
            if (bounds && bounds.isValid && bounds.isValid()) {
              map.fitBounds(bounds);
            }
          } catch (e) {}
        });
        tbody.appendChild(row);
      });
    }

    // Sorting function for table columns
    function sortTable(n) {
      const table = document.getElementById("infoTable");
      let rows = Array.from(table.tBodies[0].rows);
      const asc = table.asc = !table.asc;
      rows.sort((a, b) => {
        const x = a.cells[n].innerText.trim();
        const y = b.cells[n].innerText.trim();
        // If sorting magnitude column (index 1), sort numerically
        if (n === 1) {
          const nx = parseFloat(x) || 0;
          const ny = parseFloat(y) || 0;
          return asc ? nx - ny : ny - nx;
        }
        // Otherwise sort as strings
        return asc ? x.localeCompare(y) : y.localeCompare(x);
      });
      rows.forEach(r => table.tBodies[0].appendChild(r));
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
</body>
</html>